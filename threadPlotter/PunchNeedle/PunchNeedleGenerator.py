import sys
sys.path.insert(1,"../")
import SvgManipulation.shapeMaker as SHAPE
import SvgManipulation.pathUtils as PU
import SvgManipulation.pathOperator as PO
import SvgManipulation.fillPath as FP
import Utils.basic as UB
import SvgManipulation.Svg as SVG
from ArtGenerator.ArtGenerator import ArtGenerator
from embroidery import threadColorManagement as TCM
import settings
import os,csv,json,random,re,math,datetime,copy
axidrawHeader="'''\n auto-generated axidraw code \n'''\nfrom pyaxidraw import axidraw\nad = axidraw.AxiDraw()\nad.interactive()\nad.connect()\nad.options.pen_pos_up = 100\nad.options.pen_pos_down = 0\nad.options.pen_rate_lower=100\nad.options.pen_rate_raise=30\nad.options.model=2\nad.update()\nad.penup()\nad.moveto(0,0)\nad.pendown()\nad.penup()\n####\n"


trailDist=20

class PunchNeedleGenerator(ArtGenerator):
    def addRequirement(self,req,toolIdx):
        '''
        update setting manually
        assume axidraws are initiated
        :param req:
        :return:
        '''

        for key in req:
            self.axidraws[toolIdx].write("ad.options." + key + "=" + str(req[key]) + "\n")
        self.axidraws[toolIdx].write( "ad.update()\n")

    def initAxidraws(self):
        if not hasattr(self,"axidraws"):
            self.axidraws=[]
            for i,c in enumerate(self.colors):
                ax= open(self.bundleLoc + self.name + "_" + self.timeTag + "_" + str(i) + ".py", 'w')
                ax.write(axidrawHeader)
                ax.write("#"+c+"\n\n")
                self.axidraws.append(ax)
        self.marginInches = self.basicSettings["margins"]
        self.boundaryRect = [0, 0] + self.wh_m
    def updateDefaultColorReq(self):
        '''
        have more flexible control over the settings
        :return:
        '''
        return

    def addAxidrawPathLine(self,dotCenter,toolIdx):
        dotPathPoint=FP.makeTinyDot_pathPoints(dotCenter)
        dotPathInInches = [PU.ptToInchStrWithTranslate(pt, 96, self.marginInches["l"], self.marginInches["t"]) for pt in
                           dotPathPoint]

        self.axidraws[toolIdx].write( "ad.moveto(" + dotPathInInches[0][0] + "," + dotPathInInches[0][1] + ")\n")

        self.axidraws[toolIdx].write( "ad.lineto(" + dotPathInInches[1][0] + "," + dotPathInInches[1][1] + ")\n")
    def addAxidrawUpDown(self,dotCenter,toolIdx,appendToSVG=True):
        '''
        use only up and down
        :param dotCenter:
        :param toolIdx:
        :return:
        '''
        # if appendToSVG:
        #     self.addDefaultPath(FP.makeTinyDot(dotCenter),toolIdx=toolIdx)
        self.addDefaultPath(FP.makeTinyDot(dotCenter), toolIdx=toolIdx)
        dotPathInInches = PU.ptToInchStrWithTranslate(dotCenter, 96, self.marginInches["l"], self.marginInches["t"])
        self.axidraws[toolIdx].write("ad.moveto(" + dotPathInInches[0] + "," + dotPathInInches[1] + ")\n")
        self.axidraws[toolIdx].write("ad.pendown()\n")
        self.axidraws[toolIdx].write("ad.penup()\n")
    def addComment(self,comment,toolIdx):
        self.axidraws[toolIdx].write("##"+comment+"\n")


    def addPathsWithInitialSetting(self,dotCenters,req,toolIdx=-1):
        self.initAxidraws()

        marginInches = self.basicSettings["margins"]

        for i,dotCenter in enumerate(dotCenters):
            dotPathPoint=FP.makeTinyDot_pathPoints(dotCenter)
            currentToolIdx=toolIdx
            if toolIdx==-1:
                currentToolIdx=random.randint(0,len(self.tools)-1)
            self.addDefaultPath(SHAPE.getStraightPath(dotPathPoint),toolIdx=currentToolIdx)


            self.addRequirement(req,currentToolIdx)


            dotPathInInches=[PU.ptToInchStrWithTranslate(pt,96,marginInches["l"],marginInches["t"]) for pt in dotPathPoint]

            self.axidraws[currentToolIdx].write("ad.moveto("+dotPathInInches[0][0]+","+dotPathInInches[0][1]+")\n")

            self.axidraws[currentToolIdx].write( "ad.lineto(" + dotPathInInches[1][0] + "," + dotPathInInches[1][1] + ")\n")
    def initBasicSettings(self):
        self.defaultSetting = {
            "minDepth": {"pen_pos_down": 48, "pen_rate_raise": 20},
            "maxDepth": {"pen_pos_down": 0, "pen_rate_raise": 40},
            "trail": {"pen_pos_down": 40, "pen_rate_raise": 35}
        }
    def convertAndAddGridPaths(self,centerByColorAndRow,req=None,depth=False):
        '''
        take one of the grid generated by grid img converter
        append it to axidraw file
        :param centerByColorAndRow:generated bby exportOrderedGrid
        :return:
        '''
        self.initAxidraws()
        self.initBasicSettings()
        maxDistance=6
        if req==None:
            req=self.defaultSetting["maxDepth"]
        # print(centerByColorAndRow)
        # print(type(centerByColorAndRow))
        if depth:
            self.decideDepth()
        for toolIdx,color in enumerate(self.colors):
            if depth:
                d=self.depthMap[toolIdx]
                s=self.speedMap[toolIdx]
                req["pen_pos_down"]=d
                req["pen_rate_raise"]=s
            centersByRow=centerByColorAndRow[color]#this is sorted and reversed
            prevPt=None
            self.addRequirement(req,toolIdx)
            for i,row in enumerate(centersByRow):
                if i%10==0:
                    print("row",i)
                trailCt=0
                for pt in row:
                    update=False
                    if prevPt!=None and PU.calculateDistBetweenPoints(prevPt,pt)>maxDistance:
                        update=True
                        trail = FP.getPunchNeedleReadyDot([[prevPt, pt]], self.boundaryRect, trailDist, addTrail=False)
                        self.addComment("trail"+str(trailCt),toolIdx)
                        self.addRequirement(self.defaultSetting["trail"], toolIdx)
                        for t in trail:
                            self.addAxidrawUpDown(t,toolIdx=toolIdx,appendToSVG=False)
                        self.addComment("endTrail" + str(trailCt), toolIdx)
                        trailCt+=1
                    prevPt=pt
                    if update:
                        self.addRequirement(req, toolIdx)
                    self.addAxidrawUpDown(pt,toolIdx)
    def convertAndAddDepthGridPath(self,imgGrid):
        '''
        master method to be called by instances
        :param dotLocation: location x y
        :param dotColor: rgb triplet
        :return:
        '''
        self.initAxidraws()
        self.initBasicSettings()
        self.decideDepth()
        for i, col in enumerate(imgGrid):
            for j,(pt,rgb) in enumerate(col):
                rgbIdx=self.colors.index(TCM.rgbToString(rgb))
                depth=self.depthMap[rgbIdx]
                speed=self.speedMap[rgbIdx]
                self.addRequirement({"pen_pos_down": depth,"pen_rate_raise":speed},0)
                self.addAxidrawUpDown(pt, 0)
    def scale(self,inputVal,domainArr,rangeArr):
        '''
        d3 linearScale
        :param input:
        :param domainArr:
        :param rangeArr:
        :return:
        '''
        inputDiff=domainArr[1]-domainArr[0]
        outputDiff=rangeArr[1]-rangeArr[0]
        if inputVal-domainArr[0]==0:
            return rangeArr[0]
        return (inputVal-domainArr[0])/inputDiff*outputDiff+rangeArr[0]

    def depthSpeedCalculator(self,distances):
        '''
        given distance, calculate speed and depth
        :param distance:
        :return:
        '''
        minDepth=self.defaultSetting["minDepth"]["pen_pos_down"]
        maxDepth=self.defaultSetting["maxDepth"]["pen_pos_down"]
        minSpeed=self.defaultSetting["minDepth"]["pen_rate_raise"]
        maxSpeed=self.defaultSetting["maxDepth"]["pen_rate_raise"]
        minDistance = 6
        maxDistance = 30
        disReq={}
        for dist in distances:
            speed=self.scale(dist,[minDistance,maxDistance],[minSpeed,maxSpeed])
            depth=self.scale(dist,[minDistance,maxDistance],[minDepth,maxDepth])
            disReq[dist]={"pen_pos_down":int(depth),"pen_rate_raise":int(speed)}
        return disReq

    # def segPathIntoRandomLines(pathPoint, segLengthOptions, minX, maxX, minY, maxY):
    #     '''
    #
    #     :param pathPoint:
    #     :param segLengthOptions:list of length options
    #     :param boundaryBox: minX,maxX, minY,maxY
    #     :return:
    #     '''
    #     lines = []
    #
    def convertAndAddBackStitches(self,pathPointByColor,stitchRanges):
        '''
        :param pathPointByColor: {toolId:pathPoint(one connected)}
        :return:
        '''
        self.initAxidraws()
        self.initBasicSettings()
        self.disReq=self.depthSpeedCalculator(stitchRanges)
        minX, maxX, minY, maxY=0,self.wh_m[0],0,self.wh_m[1]
        for toolIdx in pathPointByColor:
            pathPoints=pathPointByColor[toolIdx]

            for i, pt in enumerate(pathPoints):
                if not PU.withinBox(pt, minX, maxX, minY, maxY):
                    continue
                if i == 0:
                    continue
                pt0 = pathPoints[i - 1]
                gap = random.choice(stitchRanges)
                self.addRequirement(self.disReq[gap], toolIdx)
                if pt0 != None:
                    lines=SHAPE.splitSingleLine([pt0, pt], gap)
                    for line in lines:
                        start, middle, endTag, end = PO.parseToStartAndEnd(line)
                        pt = [round(float(xy), 2) for xy in start.split(",")]
                        self.addAxidrawUpDown(pt,toolIdx)






    def addTrailAndPointFromCenters(self,centers,toolIdx,req):
        maxDistance=6
        trailCt = 0
        prevPt = None
        for i, pt in enumerate(centers):
            update = False
            if prevPt != None and PU.calculateDistBetweenPoints(prevPt, pt) > maxDistance:
                update = True
                trail = FP.getPunchNeedleReadyDot([[prevPt, pt]], self.boundaryRect, trailDist, addTrail=False)
                self.addComment("trail" + str(trailCt), toolIdx)
                self.addRequirement(self.defaultSetting["trail"], toolIdx)
                for t in trail:
                    self.addAxidrawUpDown(t, toolIdx=toolIdx, appendToSVG=False)
                self.addComment("endTrail" + str(trailCt), toolIdx)
                trailCt += 1

            if update:
                self.addRequirement(req, toolIdx)
            self.addAxidrawUpDown(pt, toolIdx)
            prevPt = pt
    def addTrianglePath(self,pathByColor,req=None):
        '''
        max to be called
        :param pathByColor: generated by grid
        :param req:
        :return:
        '''
        self.initAxidraws()
        self.defaultSetting = {
            "minDepth": {"pen_pos_down": 50, "pen_rate_raise": 20},
            "maxDepth": {"pen_pos_down": 0, "pen_rate_raise": 48},
            "trail": {"pen_pos_down": 40, "pen_rate_raise": 40}
        }
        if req == None:
            req = self.defaultSetting["maxDepth"]
        for color in self.colors:
            centers= pathByColor[color]  # this is sorted and reversed
            toolIdx = self.colors.index(color)
            self.addTrailAndPointFromCenters(centers, toolIdx, req)
    def updateColor(self,pathCollection=None):
        '''
        overwrite existing color
        :param pathCollection:
        :return:
        '''
        if not pathCollection:
            self.generateRandomTools()
            self.colors =[spec["stroke"] for spec in self.tools]
            self.initToolSvg()
        else:
            self.colors= list(pathCollection.keys())
            self.colors.sort(key=lambda rgb:sum(TCM.rgbStrToTriplet(rgb)))
            self.generateRandomTools(ballPen=False,toolCount=len(self.colors))
            self.initToolSvg()
            for i,color in enumerate(self.colors):
                self.tools[i]["stroke"]=color


    def saveSvgsAndPython(self):
        print("Saving")
        SVG.saveSVG(self.svg, self.name + "_" + self.timeTag, self.bundleLoc, "_main")
        if hasattr(self, 'tool_svgs'):
            for i, svg in enumerate(self.tool_svgs):
                SVG.saveSVG(svg, self.name, self.bundleLoc, "_" + self.timeTag + "_" + str(i))

        for i, ax in enumerate(self.axidraws):
            ax.write("\nad.disconnect()\nprint('end')\n####")
            ax.close()
        with open(self.bundleLoc + "tools.json", 'w') as outfile:
            json.dump(self.tools, outfile)
    def generateColorPlan(self):
        colorRgb=[[int(c) for c in rgb[4:-1].split(",")] for rgb in self.colors]
        plain,mixed,colorList=TCM.pickThreadColor(colorRgb)

        svg, width_height, wh_m, boundaryRect, margins=SVG.makeBasicSvgWithFoundations({"paperWidth":5,"paperHeight":len(colorRgb)*2,"inchToPx":96,"margins":{"l":0.1,"r":0.1,"t":0.1,"b":0.1}})
        boxW=wh_m[0]
        boxH=wh_m[1]/len(colorRgb)
        fontSize=15
        for i, originalColor in enumerate(colorRgb):
            y=boxH*i
            SVG.addComponent(svg, svg.g, "rect",
                             {"x": 0, "y": y, "width": boxW, "height": boxH,
                              "fill": "none",'stroke':"black"})

            #text
            idxText=SVG.addComponent(svg,svg.g,"text",{"x":fontSize,"y":fontSize+y,"style":'font-size:'+str(fontSize)+';'})
            idxText.string="Tool:"+str(i)+" "+self.colors[i]
            SVG.addComponent(svg, svg.g, "rect",
                             {"x": 0, "y": fontSize*2 + y, "width":boxW,"height":boxH/4,"fill":self.colors[i]})
            if "mixedExpect" not in colorList[i]:
                #make one grid
                gridWidth=boxW
            else:
                gridWidth=boxW/4
            jy=fontSize*3 + y+boxH/4
            textY=fontSize*3 + y+boxH/2
            # print(originalColor,colorList[i])
            for j,cObj in enumerate(colorList[i]["c"]):
                rgbStrToAppend=TCM.rgbToString(cObj["rgb"])
                jx=j*gridWidth
                SVG.addComponent(svg, svg.g, "rect",
                                 {"x": jx, "y": jy, "width": gridWidth, "height": boxH / 4,
                                  "fill": rgbStrToAppend})
                idxText = SVG.addComponent(svg, svg.g, "text", {"x": 0, "y": textY +fontSize+j*fontSize, "style": 'font-size:' + str(fontSize*0.8) + ';'})
                idxText.string = "|".join(["id:"+str(cObj["i"]),"code:"+str(cObj['code']),rgbStrToAppend])
            if "mixedExpect" in colorList[i]:
                SVG.addComponent(svg, svg.g, "rect",
                                 {"x": gridWidth*3, "y": jy, "width": gridWidth, "height": boxH / 4,
                                  "fill": TCM.rgbToString(colorList[i]["mixedExpect"]),"stroke":"black"})

        SVG.saveSVG(svg, self.name + "_" + self.timeTag, self.bundleLoc, "_tool")
        with open(self.bundleLoc + "threadColor.json", 'w') as outfile:
            json.dump({"colorList":colorList,"color":self.colors}, outfile)
    def addGapTrail(self,pt1,pt2,gap,toolId):
        '''
        :param pt1:
        :param pt2:
        :param gap:
        :return:
        '''
        trailReq = self.disReq[gap]
        self.addRequirement(trailReq, toolId)
        lineStrings = SHAPE.splitSingleLine([pt1, pt2], gap)
        for lstr in lineStrings:
            start, middle, endTag, end = PO.parseToStartAndEnd(lstr)
            pt = [round(float(xy), 2) for xy in start.split(",")]
            self.addAxidrawUpDown(pt, toolId)








